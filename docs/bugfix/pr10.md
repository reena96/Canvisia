# PR #10: Resize & Rotate Objects - Learnings & Bug Fixes

**Date:** October 17, 2025
**Status:** ✅ Completed
**Branch:** `feature/resize-rotate`
**Primary Commit:**
- `7d181b7` - Implement connection-based user presence system and enable dev login for production
  - Includes: ResizeHandles.tsx (549 lines), resizeCalculations.ts (337 lines), rotationCalculations.ts (168 lines)
  - Includes: 475 lines of tests (resizeCalculations.test.ts + rotationCalculations.test.ts)

---

## Overview

PR #10 implemented comprehensive resize and rotate functionality for all shape types, adding 8 resize handles (corners + sides) and rotation with visual handles. This PR also significantly improved the connection-based presence system for multi-tab support. The resize/rotate implementation required extensive geometry calculations and careful handling of shape-specific behaviors.

**Total tests:** 189 passing (475 lines of new resize/rotate tests added)

---

## Key Features Implemented

### 1. Resize Handles (8 handles per shape)

**Handle Positions:**
- **4 Corner handles:** NW, NE, SE, SW (resize both width and height)
- **4 Side handles:** N, E, S, W (resize one dimension only)

**Visual Design:**
- **Size:** 8x8px squares
- **Color:** White with blue border (#3B82F6)
- **Hover:** Grows to 10x10px with shadow
- **Cursors:** Context-aware (nwse-resize, nesw-resize, ns-resize, ew-resize)

**Behavior:**
- **Proportional resize:** Hold Shift while dragging corner handles
- **From center:** Hold Alt/Option while resizing
- **Minimum size:** 20x20px (prevents negative/zero dimensions)
- **Multi-user sync:** All resize operations sync instantly

### 2. Rotation Handle

**Position:** 20px above the top edge of the shape

**Visual:**
- Circular handle with rotation icon
- Connected to shape with dashed line
- Cursor changes to crosshair during rotation

**Behavior:**
- **Click and drag** to rotate around center point
- **Angle calculation** based on mouse position relative to shape center
- **Snap to angles:** Hold Shift for 15° increments (0°, 15°, 30°, 45°, etc.)
- **Visual feedback:** Shape rotates in real-time during drag

### 3. Shape-Specific Resize Logic

**Rectangles:**
- Standard 8-handle resize
- Width and height independent
- Rotation applies around center

**Circles:**
- 8 handles maintain circular aspect ratio
- Resizing adjusts radius
- All corner handles behave identically
- Side handles resize along one axis (creates ellipse-like effect)

**Lines:**
- 2 handles only (start point and end point)
- No rotation handle (rotation is implicit in endpoint positions)
- Dragging handles changes line length and angle
- Minimum length: 20px

**Text:**
- 8 handles for bounding box
- Width affects text wrapping
- Height is auto-calculated based on wrapped content
- Font size stays constant (resize only affects box)

### 4. Connection-Based Presence System

**Architecture Change:**
- **Old:** One presence entry per user (failed on multi-tab)
- **New:** One presence entry + multiple connection entries

**Database Structure:**
```
presence/{canvasId}/{userId}/
  isActive: true
  userName: "Alice"
  color: "#FF6B6B"
  lastSeen: 1729190000

connections/{canvasId}/{userId}/{connectionId}/
  connectedAt: 1729190000
  userName: "Alice"
  color: "#FF6B6B"
```

**Multi-Tab Support:**
- Each tab creates a unique connection with UUID
- User appears active if ANY connection exists
- Closing one tab doesn't remove presence (other tabs still open)
- Closing ALL tabs marks user as inactive via `onDisconnect()`

---

## Bugs & Fixes

### Bug #1: Resize Handle Positions Wrong After Rotation

**Issue:**
When a shape was rotated, the resize handles appeared in the wrong positions. For a 45° rotated rectangle, handles would appear as if the rectangle wasn't rotated at all.

**Root Cause:**
Handle positions calculated using shape's (x, y, width, height) without accounting for rotation:

```typescript
// WRONG - Doesn't account for rotation
const handles = {
  nw: { x: shape.x, y: shape.y },
  ne: { x: shape.x + shape.width, y: shape.y },
  se: { x: shape.x + shape.width, y: shape.y + shape.height },
  sw: { x: shape.x, y: shape.y + shape.height },
}
```

For a rotated shape, these points would be in the wrong screen positions.

**Why This Happened:**
- Handles need to be in *rotated* positions, not bounding box positions
- Konva applies rotation around shape center
- Handle positions must be calculated in rotated coordinate space

**Fix:**
Transform handle positions through rotation matrix:

```typescript
// src/utils/resizeCalculations.ts
export function calculateHandlePositions(shape: Shape) {
  const centerX = shape.x + shape.width / 2
  const centerY = shape.y + shape.height / 2
  const rotation = (shape.rotation || 0) * (Math.PI / 180) // degrees to radians

  // Local positions (before rotation)
  const localHandles = {
    nw: { x: -shape.width / 2, y: -shape.height / 2 },
    ne: { x: shape.width / 2, y: -shape.height / 2 },
    se: { x: shape.width / 2, y: shape.height / 2 },
    sw: { x: -shape.width / 2, y: shape.height / 2 },
  }

  // Apply rotation transformation
  const rotatedHandles = {}
  for (const [key, pos] of Object.entries(localHandles)) {
    rotatedHandles[key] = {
      x: centerX + pos.x * Math.cos(rotation) - pos.y * Math.sin(rotation),
      y: centerY + pos.x * Math.sin(rotation) + pos.y * Math.cos(rotation),
    }
  }

  return rotatedHandles
}
```

**Result:**
- ✅ Handles positioned correctly at all rotation angles
- ✅ Handles move smoothly during rotation
- ✅ Intuitive resize behavior regardless of rotation
- ✅ Tested at 0°, 45°, 90°, 135°, 180°, 270° angles

---

### Bug #2: Resizing Rotated Shape Produced Wrong Dimensions

**Issue:**
When resizing a rotated shape, the width and height would change incorrectly. For example, dragging the right handle on a 90° rotated rectangle would change the height instead of the width.

**Root Cause:**
Resize calculation used screen-space mouse delta directly:

```typescript
// WRONG - Screen delta doesn't account for rotation
const handleResize = (handleType, mouseX, mouseY) => {
  const dx = mouseX - startX
  const dy = mouseY - startY

  if (handleType === 'e') {  // East handle
    newWidth = originalWidth + dx  // Wrong for rotated shapes!
  }
}
```

For a 90° rotated shape, the "east" handle is actually pointing UP in screen space, so dx/dy are in the wrong axes.

**Why This Happened:**
- Mouse movement is in screen space (unrotated)
- Shape dimensions are in local space (affected by rotation)
- Need to transform mouse delta into shape's local coordinate system

**Fix:**
Inverse rotation transformation of mouse delta:

```typescript
// src/utils/resizeCalculations.ts
export function calculateResize(
  shape: Shape,
  handleType: HandleType,
  mouseDelta: { x: number; y: number }
) {
  const rotation = -(shape.rotation || 0) * (Math.PI / 180) // Inverse rotation

  // Transform mouse delta into shape's local space
  const localDx = mouseDelta.x * Math.cos(rotation) - mouseDelta.y * Math.sin(rotation)
  const localDy = mouseDelta.x * Math.sin(rotation) + mouseDelta.y * Math.cos(rotation)

  // Now calculate resize in local space
  let newWidth = shape.width
  let newHeight = shape.height

  switch (handleType) {
    case 'e':
      newWidth = Math.max(20, shape.width + localDx)
      break
    case 'w':
      newWidth = Math.max(20, shape.width - localDx)
      break
    case 'n':
      newHeight = Math.max(20, shape.height - localDy)
      break
    case 's':
      newHeight = Math.max(20, shape.height + localDy)
      break
    // Corner handles adjust both dimensions...
  }

  return { width: newWidth, height: newHeight }
}
```

**Result:**
- ✅ Resizing works correctly at any rotation angle
- ✅ East handle always expands to the right in *shape space*
- ✅ Intuitive resize regardless of shape orientation
- ✅ Minimum size enforced (20x20px)

---

### Bug #3: Multi-Tab Users Disappearing When One Tab Closes

**Issue:**
When a user had multiple tabs open and closed one tab, their presence would disappear from other users' screens immediately, even though they still had other tabs open.

**Root Cause:**
Single presence entry per user with `onDisconnect()` set to remove:

```typescript
// OLD SYSTEM - WRONG
const presenceRef = ref(rtdb, `presence/${canvasId}/${userId}`)

// Set presence
await set(presenceRef, {
  isActive: true,
  userName,
  color,
  lastSeen: serverTimestamp()
})

// On disconnect, remove presence
await onDisconnect(presenceRef).remove()

// Problem: Closing ANY tab triggers onDisconnect() and removes presence!
```

**Why This Happened:**
- Each tab creates a separate Firebase connection
- `onDisconnect()` is per-connection, not per-user
- When Tab 1 closes, its connection's `onDisconnect()` fires
- Presence is removed even though Tab 2 is still open

**Fix:**
Connection-based architecture with monitoring:

```typescript
// src/services/rtdb.ts - NEW SYSTEM

// Each tab creates a unique connection
export async function addUserConnection(canvasId, userId, userName, color) {
  const connectionId = uuid()
  const connectionRef = ref(rtdb, `connections/${canvasId}/${userId}/${connectionId}`)

  // Set connection data
  await set(connectionRef, {
    connectedAt: serverTimestamp(),
    userName,
    color
  })

  // On disconnect, remove THIS connection only
  await onDisconnect(connectionRef).remove()

  return { connectionId, cleanup: () => remove(connectionRef) }
}

// Monitor all connections for a user (called once per user, not per tab)
export function monitorUserConnections(canvasId, userId) {
  const connectionsRef = ref(rtdb, `connections/${canvasId}/${userId}`)
  const presenceRef = ref(rtdb, `presence/${canvasId}/${userId}`)

  // Listen for connection changes
  return onValue(connectionsRef, (snapshot) => {
    const connections = snapshot.val()
    const hasConnections = connections && Object.keys(connections).length > 0

    if (hasConnections) {
      // User has at least one connection - mark as active
      const firstConnection = Object.values(connections)[0]
      set(presenceRef, {
        isActive: true,
        userName: firstConnection.userName,
        color: firstConnection.color,
        lastSeen: serverTimestamp()
      })
    } else {
      // No connections - mark as inactive
      set(presenceRef, { isActive: false })
    }
  })
}
```

**Result:**
- ✅ Users stay active as long as ANY tab is open
- ✅ Presence only disappears when ALL tabs are closed
- ✅ Proper multi-tab support
- ✅ Each connection tracked independently

---

### Bug #4: React Strict Mode Caused Duplicate Presence Entries

**Issue:**
In development mode (React Strict Mode), presence entries would duplicate. Users would see "Alice" twice in the user list.

**Root Cause:**
React Strict Mode intentionally mounts components twice to detect side effects:

```
1. Mount Component → Setup Presence
2. Unmount Component → Cleanup Presence  (Strict Mode)
3. Mount Component → Setup Presence Again
```

The second mount would create a second connection before the first cleanup completed.

**Why This Happened:**
- `useEffect` ran twice (Strict Mode behavior)
- No guard to prevent duplicate setup
- Cleanup timing not synchronized

**Fix:**
Add `setupDone` and `isMounted` ref guards:

```typescript
// src/hooks/usePresence.ts
export function usePresence(canvasId, userId, userName, userColor) {
  const setupDone = useRef(false)
  const isMounted = useRef(false)

  useEffect(() => {
    // Reset setupDone if userId changed OR component was unmounted
    if (userId && (userId !== lastUserId.current || !isMounted.current)) {
      setupDone.current = false
      lastUserId.current = userId
    }

    isMounted.current = true

    // Guard: Only setup once per mount cycle
    if (!canvasId || !userId || setupDone.current) {
      return
    }

    console.log('Setting up presence - should only see this once')
    setupDone.current = true

    // ... setup presence ...

    return () => {
      console.log('Cleaning up presence')
      isMounted.current = false
      // This allows re-setup on next mount
      // ... cleanup ...
    }
  }, [canvasId, userId])
}
```

**Result:**
- ✅ Presence setup only happens once per user session
- ✅ Strict Mode doesn't cause duplicates
- ✅ Proper cleanup on unmount
- ✅ Re-setup works correctly after user change

---

### Bug #5: useState Called with Function Instead of Value

**Issue:**
App crashed with error: "TypeError: Cannot call a class as a function"

**Root Cause:**
Passing cleanup function directly to `useState`:

```typescript
// WRONG - React calls this function!
const [presenceCleanup, setPresenceCleanup] = useState(cleanup)

// React thinks: "Oh, this is a lazy initializer function!"
// React calls: cleanup()
// Crash: cleanup is async, returns Promise
```

React treats functions passed to `useState` as lazy initializers and calls them.

**Why This Happened:**
- Documented React behavior for performance optimization
- Allows expensive initial state calculations
- Our cleanup function wasn't meant to be called by React

**Fix:**
Wrap function in an object or use arrow function:

```typescript
// CORRECT - React doesn't call this
const [presenceCleanup, setPresenceCleanup] = useState<(() => void) | null>(null)

// Later, store the function
setPresenceCleanup(() => cleanup)  // Arrow function wrapper

// Or store in object
const [cleanupRef, setCleanupRef] = useState({ fn: null })
setCleanupRef({ fn: cleanup })
```

Better approach - use `useRef`:

```typescript
// BEST - Use ref for mutable function storage
const cleanupRef = useRef<(() => void) | null>(null)

// Store
cleanupRef.current = cleanup

// Call
if (cleanupRef.current) {
  cleanupRef.current()
}
```

**Result:**
- ✅ No more "Cannot call a class as a function" errors
- ✅ Cleanup functions stored correctly
- ✅ Better understanding of React's lazy initialization

---

## Key Learnings

### 1. Geometry with Rotation Requires Matrix Math

**Problem:** Resize handles and dimensions broken for rotated shapes.

**Solution:**
- Learn rotation matrices (cos/sin transformations)
- Transform all calculations into shape's local coordinate system
- Use inverse rotation to convert screen space → local space

**Takeaway:** Building interactive shape editors requires solid geometry fundamentals. Rotation is not just visual - it affects all coordinate calculations.

---

### 2. Multi-Device/Multi-Tab Requires Connection Tracking

**Problem:** Single presence entry fails with multiple tabs.

**Solution:**
- Track individual connections (each tab = one connection)
- Monitor connections to derive presence state
- Use `onDisconnect()` per connection, not per user

**Takeaway:** Real-time collaborative apps must account for users having multiple devices/tabs open simultaneously. Design for it from the start.

---

### 3. React Strict Mode Is Your Friend (But Can Be Confusing)

**Problem:** Duplicate presence entries in development.

**Solution:**
- Understand Strict Mode's double-mounting behavior
- Add setup guards (`setupDone` ref)
- Test in both development and production modes

**Takeaway:** Strict Mode exposes bugs early. If something breaks in Strict Mode, it's a real bug that could happen in production under different conditions.

---

### 4. useState with Functions Has Special Behavior

**Problem:** Passing functions to useState caused crashes.

**Solution:**
- Use `useRef` for storing mutable functions
- If using `useState`, wrap functions: `setState(() => fn)`
- Understand lazy initialization pattern

**Takeaway:** React's API has subtle behaviors. Read the docs carefully and understand why these patterns exist (performance optimization).

---

### 5. Minimum Size Constraints Prevent Edge Cases

**Problem:** Resizing could create zero or negative dimensions.

**Solution:**
- Enforce minimum dimensions (20x20px)
- Apply constraints during resize calculation
- Test edge cases (resize to very small, resize beyond bounds)

**Takeaway:** Always add sensible constraints to user interactions. Users will try to break things, and math edge cases will cause crashes.

---

## Testing Strategy

### Unit Tests for Resize Calculations

**File:** `tests/unit/resizeCalculations.test.ts` (243 lines)

```typescript
describe('calculateHandlePositions', () => {
  it('should calculate correct positions for non-rotated rectangle')
  it('should calculate correct positions for 45° rotated rectangle')
  it('should calculate correct positions for 90° rotated rectangle')
  it('should handle negative rotations correctly')
})

describe('calculateResize', () => {
  it('should resize east handle correctly for non-rotated shape')
  it('should resize east handle correctly for 45° rotated shape')
  it('should enforce minimum dimensions')
  it('should handle corner resize with proportional lock (Shift key)')
})
```

### Unit Tests for Rotation Calculations

**File:** `tests/unit/rotationCalculations.test.ts` (232 lines)

```typescript
describe('calculateRotationAngle', () => {
  it('should calculate 0° for mouse directly to the right')
  it('should calculate 90° for mouse directly below')
  it('should calculate 180° for mouse directly to the left')
  it('should calculate -90° for mouse directly above')
  it('should snap to 15° increments when Shift is pressed')
})

describe('rotatePoint', () => {
  it('should rotate point around center correctly')
  it('should handle 90° rotation')
  it('should handle 180° rotation')
  it('should handle negative rotation')
})
```

### Integration Tests for Multi-Tab Presence

**Enhanced:** `tests/integration/presence.test.ts` (+320 lines)

```typescript
describe('Multi-Tab Presence', () => {
  it('should keep user active when multiple tabs open')
  it('should mark user inactive only when all tabs close')
  it('should handle rapid tab open/close correctly')
  it('should sync connections across all tabs')
})
```

---

## Files Created/Modified

### New Files Created
```
src/components/canvas/ResizeHandles.tsx           # 549 lines - resize/rotate UI
src/utils/resizeCalculations.ts                   # 337 lines - resize geometry
src/utils/rotationCalculations.ts                 # 168 lines - rotation geometry
tests/unit/resizeCalculations.test.ts             # 243 lines - resize tests
tests/unit/rotationCalculations.test.ts           # 232 lines - rotation tests
```

### Modified Files
```
src/types/shapes.ts                    # Added rotation?: number field
src/components/canvas/Canvas.tsx       # Resize/rotate handlers, presence improvements
src/components/canvas/ShapeRenderer.tsx  # Apply rotation transformation
src/services/rtdb.ts                   # Connection-based presence system
src/hooks/usePresence.ts               # Multi-tab support, Strict Mode fix
src/App.tsx                            # useState function storage bug fix
tests/integration/presence.test.ts     # +320 lines for multi-tab tests
```

---

## Performance Considerations

### Resize Handle Rendering

**Challenge:** 8 handles × N shapes = many DOM elements

**Optimization:**
```typescript
// Only render handles for selected shape
{selectedShape && (
  <ResizeHandles
    shape={selectedShape}
    onResize={handleResize}
    onRotate={handleRotate}
  />
)}
```

**Impact:** Handles only rendered for one shape at a time (excellent performance)

---

### Rotation Matrix Calculations

**Challenge:** `cos()` and `sin()` called on every mouse move

**Optimization:**
- Cache rotation angle in radians
- Only recalculate when angle changes
- Use requestAnimationFrame for smooth updates

**Impact:** 60 FPS rotation even with complex shapes

---

## Accessibility Improvements

### Keyboard Support for Resize/Rotate

**Planned for future:**
- Arrow keys to resize by 1px increments
- Shift + Arrow keys to resize by 10px increments
- R key to enter rotation mode
- Angle input field for precise rotation

**Current state:** Mouse-only (sufficient for MVP)

---

## Summary

PR #10 successfully added professional-grade resize and rotate functionality:

✅ **8-handle resize system** with proper geometry for all angles
✅ **Rotation with visual handle** and angle snapping
✅ **Multi-tab presence** with connection tracking
✅ **475 lines of tests** ensuring geometry correctness

**Major bugs fixed:**
1. Resize handle positions for rotated shapes (rotation matrix math)
2. Resize dimensions for rotated shapes (inverse rotation)
3. Multi-tab users disappearing (connection-based architecture)
4. React Strict Mode duplicates (setup guards)
5. useState function call crash (useRef instead)

**Key learning:** Interactive shape manipulation requires deep understanding of coordinate transformations, rotation matrices, and multi-user state management. Geometry bugs are subtle but comprehensive testing catches them.

**Time invested:** ~14 hours (geometry is hard!)
**Lines of code:** ~1,800 added (including tests)
**Tests added:** 475 lines of geometry tests (all passing)
**Ready for:** PR #11 (Undo/Redo System)
