rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user has permission
    function hasPermission(projectId, role) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/permissions/$(projectId + '_' + request.auth.uid)) &&
        get(/databases/$(database)/documents/permissions/$(projectId + '_' + request.auth.uid)).data.role == role;
    }

    function hasAnyPermission(projectId) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/permissions/$(projectId + '_' + request.auth.uid));
    }

    // Canvas-level permission helpers
    function hasCanvasPermission(canvasPath, role) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/canvasPermissions/$(canvasPath + '_' + request.auth.uid)) &&
        get(/databases/$(database)/documents/canvasPermissions/$(canvasPath + '_' + request.auth.uid)).data.role == role;
    }

    function hasAnyCanvasPermission(canvasPath) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/canvasPermissions/$(canvasPath + '_' + request.auth.uid));
    }

    // Check if project is publicly accessible
    function isProjectPublic(projectId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/projects/$(projectId)) &&
             get(/databases/$(database)/documents/projects/$(projectId)).data.get('publicAccess', false) == true;
    }

    // Check if canvas is publicly accessible
    function isCanvasPublic(projectId, canvasId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/projects/$(projectId)/canvases/$(canvasId)) &&
             get(/databases/$(database)/documents/projects/$(projectId)/canvases/$(canvasId)).data.get('publicAccess', false) == true;
    }

    // Check if project allows public editing
    function canPublicEditProject(projectId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/projects/$(projectId)) &&
             get(/databases/$(database)/documents/projects/$(projectId)).data.get('publicAccess', false) == true &&
             get(/databases/$(database)/documents/projects/$(projectId)).data.get('publicAccessLevel', 'viewer') == 'editor';
    }

    // Check if canvas allows public editing
    function canPublicEditCanvas(projectId, canvasId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/projects/$(projectId)/canvases/$(canvasId)) &&
             get(/databases/$(database)/documents/projects/$(projectId)/canvases/$(canvasId)).data.get('publicAccess', false) == true &&
             get(/databases/$(database)/documents/projects/$(projectId)/canvases/$(canvasId)).data.get('publicAccessLevel', 'viewer') == 'editor';
    }

    // Combined check: project permission OR canvas permission OR public access
    function canAccessCanvas(projectId, canvasPath) {
      let pathParts = canvasPath.split('/');
      let canvasId = pathParts[3];
      return hasAnyPermission(projectId) ||
             hasAnyCanvasPermission(canvasPath) ||
             isProjectPublic(projectId) ||
             isCanvasPublic(projectId, canvasId);
    }

    function canEditCanvas(projectId, canvasPath) {
      let pathParts = canvasPath.split('/');
      let canvasId = pathParts[3];
      return hasPermission(projectId, 'owner') ||
             hasPermission(projectId, 'editor') ||
             hasCanvasPermission(canvasPath, 'owner') ||
             hasCanvasPermission(canvasPath, 'editor') ||
             canPublicEditProject(projectId) ||
             canPublicEditCanvas(projectId, canvasId);
    }

    // Projects: read if has permission or public, write if owner
    match /projects/{projectId} {
      allow read: if hasAnyPermission(projectId) || isProjectPublic(projectId);
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow update: if hasPermission(projectId, 'owner');
      allow delete: if hasPermission(projectId, 'owner');

      // Canvases: allow project OR canvas-level permissions
      match /canvases/{canvasId} {
        function canvasPath() {
          return 'projects/' + projectId + '/canvases/' + canvasId;
        }

        allow get, list: if canAccessCanvas(projectId, canvasPath());
        allow write: if canEditCanvas(projectId, canvasPath());

        // Objects: inherit canvas permissions
        match /objects/{objectId} {
          allow get, list: if canAccessCanvas(projectId, canvasPath());
          allow write: if canEditCanvas(projectId, canvasPath());
        }

        // Annotations: users with access can read, editors can create, users can delete their own
        match /annotations/{annotationId} {
          allow get, list: if canAccessCanvas(projectId, canvasPath());
          allow create: if request.auth != null && canEditCanvas(projectId, canvasPath());
          allow update, delete: if request.auth != null &&
                                 (resource.data.userId == request.auth.uid ||
                                  hasPermission(projectId, 'owner') ||
                                  hasCanvasPermission(canvasPath(), 'owner'));
        }

        // Chat messages
        match /chats/{tabId}/messages/{messageId} {
          allow get, list: if canAccessCanvas(projectId, canvasPath());
          allow create: if request.auth != null && canAccessCanvas(projectId, canvasPath());
          allow update: if request.auth != null && canAccessCanvas(projectId, canvasPath())
                        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']);
          allow delete: if false;
        }

        // Chat tabs
        match /chatTabs/{tabId} {
          allow get, list: if canAccessCanvas(projectId, canvasPath());
          allow create: if request.auth != null && canAccessCanvas(projectId, canvasPath());
          allow update: if request.auth != null && canAccessCanvas(projectId, canvasPath());
          allow delete: if false;
        }

        // Presence tracking
        match /presence/{userId} {
          allow get, list: if canAccessCanvas(projectId, canvasPath());
          allow write: if request.auth != null && canAccessCanvas(projectId, canvasPath());
        }
      }
    }

    // Permissions: owner can manage, users can read their own
    match /permissions/{permissionId} {
      allow read: if request.auth != null && permissionId.matches('.*_' + request.auth.uid);
      // Allow listing permissions collection (filtered by read rules)
      allow list: if request.auth != null;
      // Allow creating permission if:
      // 1. User is setting themselves as owner, OR
      // 2. User is the project owner inviting someone else
      allow create: if request.auth != null && (
        (request.resource.data.userId == request.auth.uid && request.resource.data.role == 'owner')
        ||
        hasPermission(request.resource.data.projectId, 'owner')
      );
      // Allow update/delete if user is owner of the project
      allow update, delete: if request.auth != null &&
        hasPermission(resource.data.projectId, 'owner');
    }

    // Canvas Permissions: owner can manage, users can read their own
    match /canvasPermissions/{canvasPermissionId} {
      allow read: if request.auth != null && canvasPermissionId.matches('.*_' + request.auth.uid);
      // Allow listing canvas permissions collection (filtered by read rules)
      allow list: if request.auth != null;
      // Allow creating canvas permission if:
      // 1. User is the project owner, OR
      // 2. User is the canvas owner inviting someone else
      allow create: if request.auth != null && (
        hasPermission(request.resource.data.projectId, 'owner')
        ||
        hasCanvasPermission(request.resource.data.canvasPath, 'owner')
      );
      // Allow update/delete if user is owner of the canvas or project
      allow update, delete: if request.auth != null && (
        hasPermission(resource.data.projectId, 'owner')
        ||
        hasCanvasPermission(resource.data.canvasPath, 'owner')
      );
    }

    // Legacy canvases collection (read-only for backward compatibility)
    match /canvases/{canvasId} {
      allow read: if request.auth != null;
      allow write: if false;  // Prevent new writes to old structure

      match /objects/{objectId} {
        allow read: if request.auth != null;
        allow write: if false;
      }

      // Annotations (legacy path - for backward compatibility)
      match /annotations/{annotationId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null;
        allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }

      // Chat messages (keep for backward compatibility)
      match /chats/{tabId}/messages/{messageId} {
        allow read: if true;
        allow create: if request.auth != null;
        allow update: if request.auth != null
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']);
        allow delete: if false;
      }

      // Chat tabs (keep for backward compatibility)
      match /chatTabs/{tabId} {
        allow read: if true;
        allow create: if request.auth != null;
        allow update: if request.auth != null;
        allow delete: if false;
      }
    }
  }
}
