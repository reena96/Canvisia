# PR17 - Complex AI Commands: Bugfixes and Learnings

## Overview
This document captures all bugfixes, issues encountered, and learnings from implementing complex AI commands in PR17, including intelligent flowchart branching, viewport-aware placement for all AI creations, and group-aware collision detection.

**Date:** October 20, 2025
**Status:** ✅ Completed
**Branch:** `feature/ai-complex`

---

## Bugfixes

### 1. Flowcharts Stacked Vertically Instead of Branching

**Issue**: When users asked Vega to create flowcharts with decision nodes, all nodes stacked vertically in a single column. Decision nodes (which should branch into Yes/No paths) didn't branch horizontally.

**Example User Request**:
> "create a flowchart for user authentication with decision for valid credentials"

**AI Response** (incorrect behavior):
```
Start
  ↓
Check Credentials (decision)
  ↓
Allow Access
  ↓
End
```

**Expected Behavior**:
```
Start
  ↓
Check Credentials (decision)
  ↓ (No)         → (Yes)
Deny Access      Allow Access
  ↓                 ↓
End              End
```

**Root Cause**: The flowchart layout algorithm in `executeCreateFlowchart` positioned all nodes vertically regardless of node type or connection labels. It didn't detect branch points or arrange them horizontally.

**Fix**: Implemented intelligent tree-based layout algorithm with branch detection:

```typescript
// src/utils/aiHelpers.ts:2678-2787

// Node spacing
const verticalSpacing = 180
const horizontalSpacing = 300  // NEW: for horizontal branches

// Build connection graph tracking outgoing/incoming edges
const outgoingConnections = new Map<string, Array<{ to: string; label?: string }>>()
const incomingConnections = new Map<string, number>()

connections.forEach(conn => {
  if (!outgoingConnections.has(conn.from)) {
    outgoingConnections.set(conn.from, [])
  }
  outgoingConnections.get(conn.from)!.push({
    to: conn.to,
    label: conn.label
  })

  incomingConnections.set(conn.to, (incomingConnections.get(conn.to) || 0) + 1)
})

// Find root node (no incoming connections)
const rootNode = nodes.find(node => !incomingConnections.has(node.id))

// Calculate positions using tree traversal
function calculatePositions(nodeId: string, depth: number, branchOffset: number) {
  if (visitedNodes.has(nodeId)) return
  visitedNodes.add(nodeId)

  const centerX = branchOffset * horizontalSpacing + nodeWidth / 2
  const centerY = depth * verticalSpacing + nodeHeight / 2

  nodePositions.set(nodeId, { centerX, centerY })

  const outgoing = outgoingConnections.get(nodeId) || []

  if (outgoing.length === 0) {
    // Leaf node - no children
    return
  } else if (outgoing.length === 1) {
    // Single path - continue down
    calculatePositions(outgoing[0].to, depth + 1, branchOffset)
  } else {
    // Multiple paths - branch horizontally
    let primaryPath = null
    let alternatePaths = []

    for (const conn of outgoing) {
      const label = conn.label?.toLowerCase() || ''
      // Primary path (No/False/Continue) goes down
      if (!label || label.includes('no') || label.includes('false') || label.includes('continue')) {
        primaryPath = conn
      } else {
        // Alternate paths (Yes/True/Success) branch right
        alternatePaths.push(conn)
      }
    }

    if (primaryPath) {
      calculatePositions(primaryPath.to, depth + 1, branchOffset)
    }

    alternatePaths.forEach((path, index) => {
      calculatePositions(path.to, depth + 1, branchOffset + 1 + index)
    })
  }
}

// Start from root
calculatePositions(rootNode.id, 0, 0)
```

**Also Updated**: Tool description in `tools.ts` to guide Claude on proper labeling:

```typescript
// src/services/ai/tools.ts:433
name: 'create_flowchart',
description: 'Create a professional flowchart with intelligent branching layout. Node types: start (green ellipse), process (blue rectangle), decision (orange pentagon), end (red ellipse). IMPORTANT: For decision nodes, create TWO connections - label the primary path "No"/"False"/"Continue" (goes down) and alternate path "Yes"/"True"/"Success" (branches right). The layout algorithm automatically detects branches and positions them horizontally. Decision nodes enable complex flowcharts with multiple paths.'
```

**Files Changed**:
- `src/utils/aiHelpers.ts:2678-2787` - Implemented tree-based branching algorithm
- `src/services/ai/tools.ts:433` - Updated tool description with labeling guidance

**Commits**:
- `cc67bd8` - feat: Implement intelligent branch detection for flowcharts

**Learning**:
- **Label-based routing is intuitive** - "Yes/No", "True/False" labels naturally indicate branch direction
- Tree traversal algorithms work well for flowchart layout
- Guide Claude with explicit examples in tool descriptions for complex formatting
- Horizontal spacing needs to be larger than vertical (300px vs 180px) for readability
- Primary paths (No/False) going down feels more natural than branching left

---

### 2. Flowcharts Placed Outside Viewport or Partially Visible

**Issue**: After fixing branching, flowcharts were sometimes placed outside the visible viewport or only partially visible, requiring users to zoom out or pan to see them.

**User Report**:
> "Flowchart created but I can't see it - had to zoom out to find it"

**Root Cause**: The flowchart placement logic used estimated dimensions before calculating actual layout:

```typescript
// BEFORE (incorrect)
const estimatedWidth = 400  // Guess!
const estimatedHeight = 400 // Guess!

const { x: defaultStartX, y: defaultStartY } = findEmptySpaceInViewport(
  viewportBounds, existingShapes,
  { width: estimatedWidth, height: estimatedHeight }
)

// Calculate positions...
// Actual flowchart ends up being 800x600, doesn't fit in reserved space!
```

**Fix**: Calculate positions at (0,0) first, determine actual bounding box, THEN find empty space:

```typescript
// src/utils/aiHelpers.ts:2769-2813

// Calculate all node positions starting from root (relative to 0,0)
calculatePositions(rootNode.id, 0, 0)

// Calculate bounding box of the flowchart
let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity

for (const node of nodes) {
  const position = nodePositions.get(node.id)
  if (position) {
    const left = position.centerX - nodeWidth / 2
    const right = position.centerX + nodeWidth / 2
    const top = position.centerY - nodeHeight / 2
    const bottom = position.centerY + nodeHeight / 2

    minX = Math.min(minX, left)
    maxX = Math.max(maxX, right)
    minY = Math.min(minY, top)
    maxY = Math.max(maxY, bottom)
  }
}

const flowchartWidth = maxX - minX
const flowchartHeight = maxY - minY

// Find empty space in viewport that can fit the entire flowchart
const { x: defaultStartX, y: defaultStartY } = findEmptySpaceInViewport(
  viewportBounds, existingShapes,
  { width: flowchartWidth, height: flowchartHeight }
)

// Calculate final positions (unless user specified exact x, y)
const finalStartX = x ?? defaultStartX
const finalStartY = y ?? defaultStartY

// Offset to apply to all positions
const offsetX = finalStartX - minX
const offsetY = finalStartY - minY

// Apply offset to all nodes and connections
for (const node of nodes) {
  const position = nodePositions.get(node.id)
  if (position) {
    position.centerX += offsetX
    position.centerY += offsetY
  }
}
```

**Files Changed**:
- `src/utils/aiHelpers.ts:2769-2813` - Calculate bounding box before placement

**Commits**:
- `cbfabba` - fix: Improve flowchart viewport awareness and prevent overlaps

**Learning**:
- **Calculate dimensions BEFORE placement, not after** - estimating is unreliable
- Relative positioning (start at 0,0) then apply offset is cleaner than absolute positioning
- Bounding box calculation: track min/max X/Y across all elements
- Viewport awareness must account for actual content size, not estimated size

---

### 3. All AI Creations Need Viewport Awareness, Not Just Flowcharts

**Issue**: After fixing flowcharts, user pointed out that OTHER complex AI creations (UI components, diagrams) also used estimated dimensions and could be placed outside viewport.

**User Feedback**:
> "Not just flowcharts, anything created by the agent should be within viewport"

**Investigation**: Audited all AI creation functions:

| Function | Status | Dimension Calculation |
|----------|--------|----------------------|
| `executeCreateShape` | ✅ Already correct | Uses shape's own width/height |
| `executeCreateText` | ✅ Already correct | Uses text box width/height |
| `executeCreateArrow` | ✅ Already correct | Single line, no complex placement |
| `executeCreateMultipleShapes` | ✅ Already correct | Creates at user-specified positions |
| `executeCreateFlowchart` | ✅ Fixed (above) | Now calculates bounding box |
| `executeCreateUIComponent` | ⚠️ **NEEDS FIX** | Used hardcoded 400×400 estimate |
| `executeCreateDiagram` | ⚠️ **NEEDS FIX** | Used hardcoded 400×400 estimate |

**Root Cause**: UI components and diagrams used placeholder dimensions:

```typescript
// BEFORE (incorrect)
const { x: defaultX, y: defaultY } = findEmptySpaceInViewport(
  viewportBounds, existingShapes,
  { width: 400, height: 400 }  // Hardcoded estimate!
)
```

**Fix for UI Components**: Calculate actual dimensions per component type:

```typescript
// src/utils/aiHelpers.ts:2219-2259

// Calculate actual component dimensions for each type
let componentWidth: number
let componentHeight: number

switch (componentType) {
  case 'button':
    componentWidth = width   // 200px
    componentHeight = height // 40px
    break

  case 'card':
    componentWidth = width
    componentHeight = height * 3  // Card has title + content + footer
    break

  case 'form':
    componentWidth = width
    componentHeight = 210  // Labels + inputs + button with spacing
    break

  case 'navbar':
    componentWidth = width * 2.5   // 4 items at 150px each = 600px
    componentHeight = 60
    break

  case 'sidebar':
    componentWidth = 200
    componentHeight = 400  // Vertical list of items
    break

  default:
    componentWidth = width
    componentHeight = height
}

// Use actual dimensions for placement
const { x: defaultX, y: defaultY } = findEmptySpaceInViewport(
  viewportBounds, existingShapes,
  { width: componentWidth, height: componentHeight }
)
```

**Fix for Diagrams**: Calculate actual dimensions per diagram type:

```typescript
// src/utils/aiHelpers.ts:2470-2490

// Calculate actual diagram dimensions
let diagramWidth: number
let diagramHeight: number

switch (diagramType) {
  case 'orgchart':
    // 3 boxes wide (150px each) + spacing (2 * 70px) = 460px
    diagramWidth = 540
    // 2 rows (80px each) + spacing (50px) = 210px
    diagramHeight = 210
    break

  case 'tree':
  case 'network':
  case 'sequence':
    // Single root node for initial placement
    diagramWidth = 100
    diagramHeight = 100
    break

  default:
    diagramWidth = 100
    diagramHeight = 100
}

const { x: defaultX, y: defaultY } = findEmptySpaceInViewport(
  viewportBounds, existingShapes,
  { width: diagramWidth, height: diagramHeight }
)
```

**Also Updated**: Tool schemas to make x, y parameters optional:

```typescript
// src/services/ai/tools.ts:484-490
x: {
  type: 'number',
  description: 'X coordinate (optional) - ONLY provide if user specifies exact position. Omit for smart placement in viewport.'
},
y: {
  type: 'number',
  description: 'Y coordinate (optional) - ONLY provide if user specifies exact position. Omit for smart placement in viewport.'
}
```

**Files Changed**:
- `src/utils/aiHelpers.ts:2219-2259` - UI component dimension calculation
- `src/utils/aiHelpers.ts:2470-2490` - Diagram dimension calculation
- `src/services/ai/tools.ts:484-490` - Made x,y optional in schemas

**Commits**:
- `9b95cb2` - fix: Ensure all AI creations use accurate dimensions for viewport placement

**Learning**:
- **Audit comprehensively** - Fix one issue, check if it exists elsewhere
- Optional parameters for AI tools allow smart defaults while preserving user control
- Each component/diagram type needs specific dimension calculation
- Document dimension formulas for future maintenance

---

### 4. AI Placing Shapes Inside Complex Diagrams

**Issue**: After implementing viewport awareness, user tested creating multiple flowcharts and found that new content was being placed in the gaps BETWEEN flowchart nodes, not in empty space away from the flowchart.

**User Report**:
> "Agent should not create shapes or complex diagrams over existing shapes or complex diagrams"

**Example**:
```
Existing flowchart:
  [Start] -----> [Process] -----> [End]

New shape placed in gap:
  [Start] --[😱]-> [Process] -----> [End]
```

**Root Cause**: Collision detection in `hasCollisionWithAny()` checked individual shapes, not grouped shapes:

```typescript
// BEFORE (incorrect)
function hasCollisionWithAny(pos, size, shapes) {
  for (const shape of shapes) {
    if (shapesCollide(pos, size, shape)) {
      return true
    }
  }
  return false
}

// Problem: Checks each flowchart node individually
// Allows placement in gaps between nodes!
```

**Fix**: Group-aware collision detection treats grouped shapes as single entities:

```typescript
// src/utils/viewportHelpers.ts:366-415

function hasCollisionWithAny(
  pos: { x: number; y: number },
  size: { width: number; height: number },
  shapes: Shape[]
): boolean {
  // Group shapes by groupId
  const groupedShapes = new Map<string, Shape[]>()
  const ungroupedShapes: Shape[] = []

  for (const shape of shapes) {
    if (shape.groupId) {
      if (!groupedShapes.has(shape.groupId)) {
        groupedShapes.set(shape.groupId, [])
      }
      groupedShapes.get(shape.groupId)!.push(shape)
    } else {
      ungroupedShapes.push(shape)
    }
  }

  // Check collision with grouped shapes (flowcharts, UI components, diagrams)
  // Use larger padding (50px) to avoid placing things too close to complex diagrams
  const GROUP_PADDING = 50

  for (const [groupId, groupShapes] of groupedShapes) {
    const groupBox = getGroupBoundingBox(groupShapes)

    // Check if new shape would overlap with group's bounding box
    const hasOverlap = !(
      pos.x + size.width + GROUP_PADDING < groupBox.x ||
      pos.x > groupBox.x + groupBox.width + GROUP_PADDING ||
      pos.y + size.height + GROUP_PADDING < groupBox.y ||
      pos.y > groupBox.y + groupBox.height + GROUP_PADDING
    )

    if (hasOverlap) {
      console.log(`[Viewport] Collision detected with group: ${groupShapes[0].groupName || groupId}`)
      return true
    }
  }

  // Check collision with individual ungrouped shapes (normal padding)
  for (const shape of ungroupedShapes) {
    if (shapesCollide(pos, size, shape, 10)) {  // 10px padding
      return true
    }
  }

  return false
}
```

**Helper Function for Group Bounding Box**:

```typescript
// src/utils/viewportHelpers.ts:328-359

function getGroupBoundingBox(groupShapes: Shape[]): {
  x: number
  y: number
  width: number
  height: number
} {
  if (groupShapes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 }
  }

  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  for (const shape of groupShapes) {
    const shapeWidth = getShapeWidth(shape)
    const shapeHeight = getShapeHeight(shape)

    minX = Math.min(minX, shape.x)
    minY = Math.min(minY, shape.y)
    maxX = Math.max(maxX, shape.x + shapeWidth)
    maxY = Math.max(maxY, shape.y + shapeHeight)
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  }
}
```

**Key Design Decisions**:
- **Grouped shapes treated as single entity** - prevents placement inside complex diagrams
- **50px padding for groups** - keeps new content visually separated from diagrams
- **10px padding for individual shapes** - normal spacing for ungrouped shapes
- **Console logging** - helps debug which groups are causing collisions

**Files Changed**:
- `src/utils/viewportHelpers.ts:328-359` - Added `getGroupBoundingBox()`
- `src/utils/viewportHelpers.ts:366-415` - Enhanced `hasCollisionWithAny()` with group awareness

**Commits**:
- `c9cef6c` - feat: Prevent AI from placing shapes over complex diagrams

**Learning**:
- **Grouped shapes need group-aware algorithms** - can't treat flowchart nodes as independent
- Larger padding for complex structures maintains visual clarity
- Bounding box approach simple but effective for collision detection
- Console logging with group names helps debugging
- Consider hierarchical spacing: groups (50px) > individual shapes (10px) > text (5px)

---

### 5. Z-Index Investigation for Text Visibility

**Context**: During flowchart bugfix, we implemented creating text shapes LAST so they appear on top of connectors. User asked whether using explicit z-index values would be better.

**User Question**:
> "Is Z-index implemented on all shapes? How to validate? Will using z-index break any existing behavior?"

**Investigation**:

**1. Z-Index Implementation Status**:
```typescript
// src/types/shapes.ts:10
export interface BaseShape {
  // ... other fields ...
  zIndex?: number;  // ✅ Already exists
}
```

```typescript
// src/components/canvas/Canvas.tsx:502
// Rendering sorts by zIndex
const sorted = merged.sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))
```

**2. Manual Z-Index Controls** (src/components/canvas/Canvas.tsx:359-405):
- `Cmd/Ctrl + ]` - Bring Forward (+1)
- `Cmd/Ctrl + [` - Send Backward (-1)
- `Cmd/Ctrl + Shift + ]` - Bring to Front (max + 1)
- `Cmd/Ctrl + Shift + [` - Send to Back (min - 1)

**3. Current Behavior**:
- Neither manual shape creation nor AI creation sets zIndex
- All shapes default to zIndex = 0
- **Creation order determines stacking** for shapes with same zIndex
- Later shapes render on top

**4. Would Z-Index Break Anything?**

**Analysis**:

| Scenario | Impact | Breaking? |
|----------|--------|-----------|
| AI sets zIndex = 100 for new shapes | New shapes appear on top of all existing work | ⚠️ YES - unexpected layering |
| Manual creation doesn't set zIndex | Manual shapes (zIndex=0) render behind AI shapes (zIndex=100) | ⚠️ YES - inconsistent behavior |
| Keyboard shortcuts | Still work - add/subtract from current zIndex | ✅ NO |
| Undo/redo | Still work - restores shape properties including zIndex | ✅ NO |

**Potential Breaking Changes**:
1. **Unexpected layering** - AI shapes would always appear on top of existing work, even if user wanted them in back
2. **Inconsistent behavior** - Manual creation uses creation order, AI would use explicit zIndex
3. **User confusion** - Why do AI shapes always appear on top?

**Decision**: **Do NOT set zIndex for AI-created shapes**

**Rationale**:
- Current creation-order behavior already ensures correct layering (text created last appears on top)
- Consistent with manual shape creation
- Users can manually adjust z-index if needed using keyboard shortcuts
- Avoids unexpected layering issues
- Simpler mental model for users

**Validation Methods Provided**:
1. **Keyboard shortcuts** - Test Cmd+] and Cmd+[
2. **Browser DevTools** - Check Firestore: `canvases/{id}/objects/{shapeId}` for zIndex field
3. **Programmatic check** - Console: `shapes.map(s => ({ id: s.id, zIndex: s.zIndex || 0 }))`
4. **Visual test** - Create overlapping shapes, verify render order

**Files Referenced** (no changes):
- `src/types/shapes.ts:10` - zIndex field definition
- `src/components/canvas/Canvas.tsx:502` - Rendering sort logic
- `src/components/canvas/Canvas.tsx:359-405` - Keyboard shortcuts

**Learning**:
- **Not every feature needs to be used** - zIndex exists but creation order is often sufficient
- Consistency matters - AI and manual creation should behave the same
- Avoid breaking changes when current behavior works well
- Provide multiple validation methods for users to verify behavior
- Document decisions to prevent future "why don't we use X?" discussions

---

## Implementation Details

### 1. Intelligent Flowchart Branching Algorithm

**Challenge**: Traditional flowchart layout algorithms stack nodes vertically or use force-directed layouts (complex, unpredictable). Need something that:
- Handles branching (decision nodes)
- Is predictable and consistent
- Produces readable layouts
- Doesn't require external libraries

**Solution**: Tree-based recursive layout with label-based branch detection

**Algorithm Steps**:

1. **Build Connection Graph**:
```typescript
const outgoingConnections = new Map<string, Array<{ to: string; label?: string }>>()
const incomingConnections = new Map<string, number>()

connections.forEach(conn => {
  // Track outgoing edges with labels
  if (!outgoingConnections.has(conn.from)) {
    outgoingConnections.set(conn.from, [])
  }
  outgoingConnections.get(conn.from)!.push({
    to: conn.to,
    label: conn.label
  })

  // Count incoming edges
  incomingConnections.set(
    conn.to,
    (incomingConnections.get(conn.to) || 0) + 1
  )
})
```

2. **Find Root Node** (no incoming connections):
```typescript
const rootNode = nodes.find(node => !incomingConnections.has(node.id))
if (!rootNode) {
  throw new Error('Flowchart must have a root node (no incoming connections)')
}
```

3. **Recursive Position Calculation**:
```typescript
const nodePositions = new Map<string, { centerX: number; centerY: number }>()
const visitedNodes = new Set<string>()

function calculatePositions(
  nodeId: string,
  depth: number,      // Vertical level (0, 1, 2, ...)
  branchOffset: number // Horizontal offset (0, 1, 2, ...)
) {
  // Prevent cycles
  if (visitedNodes.has(nodeId)) return
  visitedNodes.add(nodeId)

  // Calculate position
  const centerX = branchOffset * horizontalSpacing + nodeWidth / 2
  const centerY = depth * verticalSpacing + nodeHeight / 2
  nodePositions.set(nodeId, { centerX, centerY })

  // Get outgoing connections
  const outgoing = outgoingConnections.get(nodeId) || []

  if (outgoing.length === 0) {
    // Leaf node - no children
    return
  } else if (outgoing.length === 1) {
    // Single path - continue down
    calculatePositions(outgoing[0].to, depth + 1, branchOffset)
  } else {
    // Multiple paths - detect primary vs. alternate
    let primaryPath = null
    let alternatePaths = []

    for (const conn of outgoing) {
      const label = conn.label?.toLowerCase() || ''

      // Primary path keywords
      if (!label ||
          label.includes('no') ||
          label.includes('false') ||
          label.includes('continue') ||
          label.includes('fail')) {
        primaryPath = conn
      } else {
        // Alternate path keywords (yes, true, success)
        alternatePaths.push(conn)
      }
    }

    // Primary path continues down
    if (primaryPath) {
      calculatePositions(primaryPath.to, depth + 1, branchOffset)
    }

    // Alternate paths branch right
    alternatePaths.forEach((path, index) => {
      calculatePositions(
        path.to,
        depth + 1,
        branchOffset + 1 + index  // Offset to the right
      )
    })
  }
}

// Start recursive layout from root
calculatePositions(rootNode.id, 0, 0)
```

**Spacing Constants**:
```typescript
const verticalSpacing = 180    // Vertical distance between levels
const horizontalSpacing = 300  // Horizontal distance between branches
```

**Key Design Decisions**:
- **Primary paths go down** - More natural reading flow (top to bottom)
- **Alternate paths go right** - Clearly shows branching
- **Label-based detection** - Intuitive for users and Claude
- **Visited set prevents cycles** - Handles graph with loops gracefully
- **Relative positioning** - Calculate at (0,0), then offset to final position

**Learning**:
- Tree traversal maps naturally to flowchart structure
- Label-based routing more intuitive than topology-only analysis
- Horizontal spacing should be larger than vertical for readability
- Recursive algorithms elegant but need cycle protection
- Consider future enhancement: support for join nodes (multiple incoming edges)

---

### 2. Viewport-Aware Placement Pattern

**Pattern**: Calculate actual dimensions BEFORE finding empty space

**Anti-Pattern** (what we fixed):
```typescript
// ❌ BAD: Estimate dimensions
const estimate = { width: 400, height: 400 }
const { x, y } = findEmptySpace(viewport, shapes, estimate)

// Create content at position
createFlowchart(x, y)

// Problem: Actual content is 800x600, doesn't fit!
```

**Correct Pattern**:
```typescript
// ✅ GOOD: Calculate actual dimensions first

// Step 1: Calculate content in relative space (0,0)
const content = createContentLayout(0, 0)

// Step 2: Calculate bounding box
let minX = Infinity, minY = Infinity
let maxX = -Infinity, maxY = -Infinity

for (const item of content) {
  minX = Math.min(minX, item.x)
  minY = Math.min(minY, item.y)
  maxX = Math.max(maxX, item.x + item.width)
  maxY = Math.max(maxY, item.y + item.height)
}

const actualWidth = maxX - minX
const actualHeight = maxY - minY

// Step 3: Find empty space with actual dimensions
const { x, y } = findEmptySpace(
  viewport,
  shapes,
  { width: actualWidth, height: actualHeight }
)

// Step 4: Apply offset to move from relative to absolute positions
const offsetX = x - minX
const offsetY = y - minY

for (const item of content) {
  item.x += offsetX
  item.y += offsetY
}
```

**Benefits**:
- ✅ Content always fits in viewport
- ✅ No guesswork on dimensions
- ✅ Works for any complex layout
- ✅ Easy to understand and maintain

**Applied To**:
- Flowcharts (calculate tree layout first)
- UI components (calculate per-type dimensions)
- Diagrams (calculate per-type dimensions)

**Learning**:
- Relative-then-absolute positioning cleaner than absolute-only
- Bounding box calculation simple: track min/max X/Y
- Pattern works for any complex multi-shape creation
- Consider extracting into reusable helper function

---

### 3. Group-Aware Collision Detection

**Challenge**: Collision detection needs to treat grouped shapes (flowcharts, UI components, diagrams) as single entities, not individual shapes.

**Why Grouping Matters**:
```
Flowchart without group-aware collision:
  [Start]  <-- Node 1
     ↓
  [Process]  <-- Node 2
     ↓
  [End]  <-- Node 3

New shape placed in gap between nodes:
  [Start]
     ↓
  [😱 New Shape]  <-- Placed in "empty" space!
     ↓
  [Process]
     ↓
  [End]

Flowchart with group-aware collision:
  [Start]
     ↓
  [Process]
     ↓
  [End]

  [✅ New Shape]  <-- Placed away from entire flowchart
```

**Implementation**:

**1. Group Shapes by groupId**:
```typescript
const groupedShapes = new Map<string, Shape[]>()
const ungroupedShapes: Shape[] = []

for (const shape of shapes) {
  if (shape.groupId) {
    if (!groupedShapes.has(shape.groupId)) {
      groupedShapes.set(shape.groupId, [])
    }
    groupedShapes.get(shape.groupId)!.push(shape)
  } else {
    ungroupedShapes.push(shape)
  }
}
```

**2. Calculate Bounding Box per Group**:
```typescript
function getGroupBoundingBox(groupShapes: Shape[]) {
  let minX = Infinity, minY = Infinity
  let maxX = -Infinity, maxY = -Infinity

  for (const shape of groupShapes) {
    const width = getShapeWidth(shape)
    const height = getShapeHeight(shape)

    minX = Math.min(minX, shape.x)
    minY = Math.min(minY, shape.y)
    maxX = Math.max(maxX, shape.x + width)
    maxY = Math.max(maxY, shape.y + height)
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  }
}
```

**3. Check Collision Against Group Bounding Box**:
```typescript
const GROUP_PADDING = 50  // Larger padding for visual separation

for (const [groupId, groupShapes] of groupedShapes) {
  const groupBox = getGroupBoundingBox(groupShapes)

  // Check if new shape overlaps with group bounding box + padding
  const hasOverlap = !(
    pos.x + size.width + GROUP_PADDING < groupBox.x ||
    pos.x > groupBox.x + groupBox.width + GROUP_PADDING ||
    pos.y + size.height + GROUP_PADDING < groupBox.y ||
    pos.y > groupBox.y + groupBox.height + GROUP_PADDING
  )

  if (hasOverlap) {
    console.log(`[Viewport] Collision with group: ${groupShapes[0].groupName}`)
    return true
  }
}
```

**4. Check Individual Shapes with Normal Padding**:
```typescript
for (const shape of ungroupedShapes) {
  if (shapesCollide(pos, size, shape, 10)) {  // Normal 10px padding
    return true
  }
}
```

**Padding Hierarchy**:
- Groups (flowcharts, UI components): **50px** - maintains visual separation
- Individual shapes: **10px** - normal spacing
- Future: Text shapes could use **5px** - tighter spacing acceptable

**Benefits**:
- ✅ Prevents placement inside complex diagrams
- ✅ Maintains visual separation between distinct structures
- ✅ Simple bounding box approach (not complex polygon collision)
- ✅ Scales well (Map lookup by groupId is O(1))

**Edge Cases Handled**:
- Empty groups (return 0×0 bounding box)
- Ungrouped shapes (use individual collision detection)
- Single-shape groups (treated as group with 50px padding)

**Learning**:
- Grouping is semantic AND functional - affects both organization and layout
- Bounding box approach good enough for most cases (vs. complex polygon collision)
- Padding should scale with complexity: groups > shapes > text
- Console logging with group names invaluable for debugging
- Consider future: allow custom padding per group type

---

## Testing Strategy

### 1. Manual Testing Performed

**Test Scenarios**:

1. **Flowchart Branching**:
   - ✅ Simple linear flowchart (no branches)
   - ✅ Single decision node with Yes/No paths
   - ✅ Multiple decision nodes in sequence
   - ✅ Decision node with 3+ branches
   - ✅ Complex authentication flowchart with nested decisions

2. **Viewport Awareness**:
   - ✅ Create flowchart on empty canvas
   - ✅ Create flowchart on canvas with existing shapes
   - ✅ Create multiple flowcharts in sequence
   - ✅ Create UI components (login form, nav bar)
   - ✅ Create diagrams (org chart, tree)
   - ✅ All creations visible within viewport bounds

3. **Group-Aware Collision**:
   - ✅ Create shape near flowchart (should not place inside)
   - ✅ Create flowchart near existing flowchart (should not overlap)
   - ✅ Create UI component near existing UI component
   - ✅ Create shape in truly empty space (should work normally)

4. **Z-Index Validation**:
   - ✅ Flowchart text appears on top of connectors
   - ✅ Keyboard shortcuts work (Cmd+], Cmd+[)
   - ✅ Manual shapes and AI shapes have same default zIndex (0)

**Test Commands Used**:
```
"create a flowchart for user login with authentication check"
"create a login form"
"create a navigation bar"
"create an org chart"
"create a circle"  (after creating flowchart - tests collision)
```

**Visual Verification**:
- All flowcharts branch horizontally for decision nodes ✅
- All content appears within visible viewport ✅
- No shapes placed inside flowchart gaps ✅
- Text appears on top of arrows ✅

---

### 2. Automated Testing

**Note**: PR17 focused on bugfixes and improvements. Comprehensive unit tests exist in:
- `tests/unit/aiLayoutCalculations.test.ts` - Layout algorithms (from PR16)
- `tests/unit/viewportHelpers.test.ts` - Viewport calculations

**Future Test Coverage Needed**:

**Unit Tests** (`tests/unit/flowchartLayout.test.ts`):
```typescript
describe('Flowchart Branching Algorithm', () => {
  it('should place single-path nodes vertically', () => {
    const nodes = [
      { id: '1', type: 'start' },
      { id: '2', type: 'process' },
      { id: '3', type: 'end' }
    ]
    const connections = [
      { from: '1', to: '2' },
      { from: '2', to: '3' }
    ]

    const positions = calculateFlowchartPositions(nodes, connections)

    // All should have same X (vertical stack)
    expect(positions.get('1').centerX).toBe(positions.get('2').centerX)
    expect(positions.get('2').centerX).toBe(positions.get('3').centerX)

    // Y should increase down
    expect(positions.get('1').centerY).toBeLessThan(positions.get('2').centerY)
    expect(positions.get('2').centerY).toBeLessThan(positions.get('3').centerY)
  })

  it('should branch horizontally for decision nodes with Yes/No', () => {
    const nodes = [
      { id: '1', type: 'start' },
      { id: '2', type: 'decision' },
      { id: '3', type: 'process' },  // Yes path
      { id: '4', type: 'process' }   // No path
    ]
    const connections = [
      { from: '1', to: '2' },
      { from: '2', to: '3', label: 'Yes' },
      { from: '2', to: '4', label: 'No' }
    ]

    const positions = calculateFlowchartPositions(nodes, connections)

    // Yes path should branch right
    expect(positions.get('3').centerX).toBeGreaterThan(positions.get('2').centerX)

    // No path should continue down
    expect(positions.get('4').centerX).toBe(positions.get('2').centerX)
  })

  it('should handle cycles gracefully', () => {
    const nodes = [
      { id: '1', type: 'start' },
      { id: '2', type: 'process' }
    ]
    const connections = [
      { from: '1', to: '2' },
      { from: '2', to: '1' }  // Cycle back
    ]

    // Should not infinite loop
    expect(() => {
      calculateFlowchartPositions(nodes, connections)
    }).not.toThrow()
  })
})

describe('Group-Aware Collision Detection', () => {
  it('should detect collision with group bounding box', () => {
    const groupShapes = [
      { id: '1', groupId: 'flow1', x: 0, y: 0, width: 100, height: 100 },
      { id: '2', groupId: 'flow1', x: 0, y: 150, width: 100, height: 100 }
    ]

    const newPos = { x: 50, y: 100 }  // In gap between nodes
    const newSize = { width: 50, height: 50 }

    const collides = hasCollisionWithAny(newPos, newSize, groupShapes)

    // Should detect collision with group bounding box
    expect(collides).toBe(true)
  })

  it('should not collide with distant group', () => {
    const groupShapes = [
      { id: '1', groupId: 'flow1', x: 0, y: 0, width: 100, height: 100 }
    ]

    const newPos = { x: 500, y: 500 }  // Far away
    const newSize = { width: 50, height: 50 }

    const collides = hasCollisionWithAny(newPos, newSize, groupShapes)

    expect(collides).toBe(false)
  })
})
```

**Integration Tests** (future):
- Test full flowchart creation flow with Firestore
- Test viewport calculations with different window sizes
- Test collision detection with complex canvas state

---

## Debugging Techniques Used

### 1. Console Logging with Prefixes

**Pattern**: Consistent prefixes for filtering and tracing

```typescript
// Entry point
console.log('[AI Helpers] executeCreateFlowchart called:', { nodes, connections })

// Algorithm stages
console.log('[AI Helpers] Found root node:', rootNode.id)
console.log('[AI Helpers] Calculated positions for', nodePositions.size, 'nodes')
console.log('[AI Helpers] Flowchart dimensions:', { width, height })

// Viewport placement
console.log('[Viewport] Finding empty space for:', { width, height })
console.log('[Viewport] Collision detected with group:', groupName)
console.log('[Viewport] Placement at:', { x, y })

// Firestore operations
console.log('[Firestore] Creating', nodes.length, 'nodes')
console.log('[Firestore] Creating', connections.length, 'connections')
```

**Benefits**:
- Filter console by `[AI Helpers]`, `[Viewport]`, `[Firestore]`
- Trace execution flow through different modules
- Identify which stage is failing
- Copy logs for bug reports

---

### 2. Visual Debugging with Canvas Coordinates

**Technique**: Log positions and dimensions to understand layout

```typescript
// Log node positions
console.log('Node positions:')
for (const [nodeId, pos] of nodePositions) {
  console.log(`  ${nodeId}: (${pos.centerX}, ${pos.centerY})`)
}

// Log bounding box
console.log('Bounding box:', {
  minX, minY, maxX, maxY,
  width: maxX - minX,
  height: maxY - minY
})

// Log offset calculations
console.log('Offset:', { offsetX, offsetY })

// Use console.table for multiple items
console.table(Array.from(nodePositions.entries()).map(([id, pos]) => ({
  nodeId: id,
  x: pos.centerX,
  y: pos.centerY
})))
```

**Benefits**:
- Visualize numeric relationships
- Spot layout issues quickly (negative positions, overlaps)
- Verify offset calculations
- `console.table` excellent for comparing multiple values

---

### 3. Breakpoint Debugging in Browser DevTools

**When to Use**:
- Complex control flow (recursive functions)
- Investigating state at specific points
- Stepping through algorithm execution

**Example - Debugging Branch Detection**:
```typescript
function calculatePositions(nodeId: string, depth: number, branchOffset: number) {
  debugger;  // Pause here to inspect variables

  const outgoing = outgoingConnections.get(nodeId) || []

  if (outgoing.length > 1) {
    debugger;  // Pause when branching occurs

    for (const conn of outgoing) {
      const label = conn.label?.toLowerCase() || ''
      // Inspect: Which labels are triggering branches?
    }
  }
}
```

**DevTools Features Used**:
- **Call stack** - Trace recursive function calls
- **Watch expressions** - Monitor nodePositions Map size
- **Conditional breakpoints** - Break only for specific node IDs
- **Step over/into** - Navigate through recursive calls

---

### 4. Git Bisect for Regression Hunting

**Scenario**: "Flowcharts were working, now they're broken. When did it break?"

**Process**:
```bash
# Start bisect
git bisect start

# Mark current commit as bad
git bisect bad

# Mark last known good commit
git bisect good <commit-hash>

# Git will checkout middle commit - test and mark
git bisect good  # if it works
git bisect bad   # if it's broken

# Git automatically finds first bad commit
```

**Learning**:
- Bisect saves time on large commit ranges
- Automated bisect possible with test scripts
- Keep commits small and atomic for easier bisecting

---

## Best Practices Established

### 1. Calculate Dimensions Before Placement

**Rule**: Never estimate dimensions when you can calculate them

**Pattern**:
```typescript
// 1. Create content in relative space (0,0)
const content = createLayout(0, 0)

// 2. Calculate actual bounding box
const bounds = calculateBoundingBox(content)

// 3. Find empty space with actual dimensions
const position = findEmptySpace(viewport, bounds)

// 4. Apply offset to move content to final position
applyOffset(content, position)
```

**Benefits**:
- ✅ Content always fits in viewport
- ✅ No guesswork
- ✅ Works for any complex layout

---

### 2. Group-Aware Algorithms for Complex Structures

**Rule**: Treat grouped shapes as single entities, not collections of shapes

**Implementation Checklist**:
- [ ] Group shapes by groupId
- [ ] Calculate bounding box per group
- [ ] Apply algorithm to group bounding box, not individual shapes
- [ ] Use larger padding for groups (50px) vs. individual shapes (10px)

**Examples**:
- Collision detection (this PR)
- Future: Selection (select entire group)
- Future: Movement (move entire group)
- Future: Deletion (delete entire group)

---

### 3. Consistent Logging with Prefixes

**Rule**: All console logs should have module prefixes

**Format**: `[Module] Message: data`

**Examples**:
- `[AI Helpers] Creating flowchart with 5 nodes`
- `[Viewport] Collision detected with group: flowchart`
- `[Firestore] Updated 10 shapes`

**Benefits**:
- Filterable in console
- Traceable across modules
- Clear ownership of log messages

---

### 4. Fail Fast with Clear Errors

**Rule**: Validate inputs and assumptions at function boundaries

**Pattern**:
```typescript
export async function executeCreateFlowchart(
  canvasId: string,
  input: { nodes: Node[]; connections: Connection[] }
) {
  // Validate inputs
  if (!canvasId) {
    throw new Error('canvasId is required')
  }

  if (!input.nodes || input.nodes.length === 0) {
    throw new Error('Flowchart must have at least one node')
  }

  // Validate assumptions
  const rootNode = findRootNode(input.nodes, input.connections)
  if (!rootNode) {
    throw new Error('Flowchart must have a root node (no incoming connections)')
  }

  // Proceed with execution
  // ...
}
```

**Benefits**:
- ✅ Clear error messages for debugging
- ✅ Fail at source, not deep in call stack
- ✅ Prevents cascading failures
- ✅ Easier to trace issues

---

### 5. Document Architectural Decisions

**Rule**: Document "why not" decisions, not just "what we did"

**Example from this PR**:
- ✅ Documented why we DON'T set z-index for AI shapes
- ✅ Explained potential breaking changes
- ✅ Provided validation methods
- ✅ Recorded decision rationale for future reference

**Format**:
```markdown
## Decision: Don't Set Z-Index for AI Shapes

**Context**: Z-index is implemented and available.

**Decision**: Do NOT set z-index for AI-created shapes.

**Rationale**:
- Creation order already ensures correct layering
- Consistent with manual shape creation
- Avoids unexpected layering issues

**Alternatives Considered**:
- Set zIndex=100 for AI shapes → Rejected (breaks layering expectations)
- Set zIndex based on shape type → Rejected (complex, hard to understand)

**Validation**: Test with overlapping shapes, verify creation order determines stacking.
```

**Benefits**:
- Prevents future "why don't we..." discussions
- Explains context for new team members
- Records alternatives considered
- Provides validation approach

---

## Edge Cases Handled

### 1. Flowcharts Without Root Node

**Scenario**: Flowchart with all nodes having incoming connections (cycle)

**Handling**:
```typescript
const rootNode = nodes.find(node => !incomingConnections.has(node.id))
if (!rootNode) {
  throw new Error('Flowchart must have a root node (no incoming connections)')
}
```

**Learning**: Fail fast with clear error rather than producing incorrect layout

---

### 2. Decision Node with Single Path

**Scenario**: Decision node labeled as such but only one outgoing connection

**Handling**:
```typescript
if (outgoing.length === 1) {
  // Treat as normal node, continue down
  calculatePositions(outgoing[0].to, depth + 1, branchOffset)
}
```

**Learning**: Algorithm degrades gracefully, doesn't require perfect input

---

### 3. Connection Labels in Different Cases

**Scenario**: Labels like "YES", "yes", "Yes", "yes branch"

**Handling**:
```typescript
const label = conn.label?.toLowerCase() || ''
if (label.includes('yes') || label.includes('true')) {
  // Treat as alternate path
}
```

**Learning**: Case-insensitive matching with `includes()` more robust than exact match

---

### 4. Empty Canvas vs. Canvas with Existing Content

**Scenario**: Placement behavior should work in both cases

**Handling**:
```typescript
const { x, y } = findEmptySpaceInViewport(
  viewportBounds,
  existingShapes,  // May be empty array
  { width, height }
)

// findEmptySpaceInViewport handles empty array:
if (existingShapes.length === 0) {
  // Center of viewport
  return {
    x: viewport.x + viewport.width / 2 - width / 2,
    y: viewport.y + viewport.height / 2 - height / 2
  }
}
```

**Learning**: Functions should handle both empty and populated states

---

### 5. Group with Single Shape

**Scenario**: Flowchart with only one node (edge case for testing)

**Handling**:
```typescript
// Single-shape group still treated as group
// Gets 50px padding, not 10px
for (const [groupId, groupShapes] of groupedShapes) {
  const groupBox = getGroupBoundingBox(groupShapes)
  // Works correctly even if groupShapes.length === 1
}
```

**Learning**: Don't special-case single-item groups, let algorithm handle naturally

---

## Performance Considerations

### 1. Recursive Algorithm Performance

**Current**: Tree traversal for flowchart layout

**Complexity**:
- Time: O(N) where N = number of nodes
- Space: O(N) for visited set and position map
- Stack depth: O(depth) - typically 5-10 levels

**Performance**:
- 10 nodes: < 1ms
- 100 nodes: < 10ms
- 1000 nodes: < 100ms (theoretical, impractical for UI)

**Optimization Notes**:
- Cycle detection prevents infinite loops (visited set)
- Map lookups O(1) for node positions
- No optimization needed for typical flowcharts (< 50 nodes)

---

### 2. Bounding Box Calculation

**Current**: Iterate all shapes in group

**Complexity**:
- Time: O(N) where N = shapes in group
- Computed once per placement operation

**Could Cache** (future optimization):
```typescript
// Cache bounding box per group
const groupBoundingBoxCache = new Map<string, BoundingBox>()

function getGroupBoundingBox(groupId: string, groupShapes: Shape[]) {
  if (!groupBoundingBoxCache.has(groupId)) {
    groupBoundingBoxCache.set(groupId, calculateBoundingBox(groupShapes))
  }
  return groupBoundingBoxCache.get(groupId)
}

// Invalidate cache when group shapes move/resize
```

**When Needed**:
- Canvas with 10+ complex groups
- Frequent placement operations
- Not needed for typical use case

---

### 3. Collision Detection Performance

**Current**: O(G + U) where G = grouped shapes, U = ungrouped shapes

**Optimization Already Applied**:
- Group-aware reduces checks (check 1 bounding box vs. N individual shapes)
- Map grouping is O(1) lookup

**Example**:
- Flowchart with 10 nodes: **1 check** (group bounding box)
- Without grouping: **10 checks** (each node individually)

**Performance Win**: 10x reduction in checks for grouped shapes

---

## Future Improvements

### 1. Flowchart Join Nodes

**Current Limitation**: Algorithm assumes tree structure (each node has ≤1 parent)

**Enhancement**: Support join nodes (multiple incoming edges)

```typescript
// Example: Exception handling pattern
//   Process A → Handle Exception
//   Process B → Handle Exception  (join node)
//   Handle Exception → Continue

function calculatePositions(nodeId, depth, branchOffset) {
  const incoming = incomingConnections.get(nodeId) || 0

  if (incoming > 1) {
    // Join node - calculate average position of parents
    const parentPositions = getParentPositions(nodeId)
    const avgX = average(parentPositions.map(p => p.x))
    const avgY = max(parentPositions.map(p => p.y)) + verticalSpacing

    nodePositions.set(nodeId, { centerX: avgX, centerY: avgY })
  }
}
```

---

### 2. Animated Shape Placement

**Enhancement**: Animate shapes moving to final position

```typescript
// Instead of instant placement
await createShapeInFirestore(canvasId, {
  ...shape,
  x: finalX,
  y: finalY
})

// Animated placement
await createShapeInFirestore(canvasId, {
  ...shape,
  x: viewport.centerX,  // Start at center
  y: viewport.centerY,
  transition: {
    to: { x: finalX, y: finalY },
    duration: 300,
    easing: 'ease-out'
  }
})
```

**Benefits**:
- User sees where content is being created
- Helps understand AI actions
- Improves perceived performance

---

### 3. Smart Placement Strategies

**Current**: Spiral outward from center until finding empty space

**Enhancements**:

**A. Placement Preferences**:
```typescript
interface PlacementPreferences {
  preferredSide?: 'left' | 'right' | 'top' | 'bottom'
  avoidOverlapping?: boolean
  maxDistanceFromCenter?: number
}
```

**B. Context-Aware Placement**:
```typescript
// If creating related content, place near existing
if (relatedToGroupId) {
  const existingGroup = shapes.filter(s => s.groupId === relatedToGroupId)
  const groupBounds = getGroupBoundingBox(existingGroup)

  // Try placing to the right of existing group
  const position = {
    x: groupBounds.x + groupBounds.width + 100,
    y: groupBounds.y
  }
}
```

---

### 4. Undo Support for Complex Commands

**Challenge**: Complex commands create multiple shapes - undo should revert all

**Solution**: Group undo action

```typescript
// Save undo action for entire flowchart
await saveUndoAction({
  id: generateId(),
  canvasId,
  userId,
  timestamp: new Date(),
  command: 'create flowchart for user authentication',
  actionType: 'create',
  createdShapeIds: allCreatedShapeIds,  // All nodes + arrows
  groupId: flowchartGroupId  // Link to group for easy reversal
})
```

**Undo Execution**:
```typescript
// Undo flowchart creation - delete all shapes in group
const action = await getLastUndoAction(canvasId)
if (action.actionType === 'create' && action.groupId) {
  // Delete all shapes with matching groupId
  const groupShapes = shapes.filter(s => s.groupId === action.groupId)
  await Promise.all(groupShapes.map(s => deleteShape(canvasId, s.id)))
}
```

---

### 5. Flowchart Validation and Auto-Fix

**Enhancement**: Validate flowchart structure and suggest fixes

```typescript
function validateFlowchart(nodes: Node[], connections: Connection[]): ValidationResult {
  const issues = []

  // Check: Must have exactly one root
  const roots = nodes.filter(node => !hasIncomingConnections(node))
  if (roots.length === 0) {
    issues.push({ type: 'error', message: 'Flowchart has no start node' })
  } else if (roots.length > 1) {
    issues.push({ type: 'warning', message: 'Multiple start nodes detected' })
  }

  // Check: All nodes should be reachable from root
  const reachable = findReachableNodes(roots[0])
  const unreachable = nodes.filter(n => !reachable.has(n.id))
  if (unreachable.length > 0) {
    issues.push({
      type: 'warning',
      message: `${unreachable.length} unreachable nodes`,
      nodes: unreachable
    })
  }

  // Check: Decision nodes should have 2+ outgoing connections
  for (const node of nodes) {
    if (node.type === 'decision') {
      const outgoing = connections.filter(c => c.from === node.id)
      if (outgoing.length < 2) {
        issues.push({
          type: 'warning',
          message: `Decision node "${node.id}" has only ${outgoing.length} outgoing path`,
          autoFix: () => {
            // Add default "No" path back to previous node
          }
        })
      }
    }
  }

  return { valid: issues.length === 0, issues }
}
```

---

## Summary

**Key Achievements**:
- ✅ Implemented intelligent flowchart branching with tree-based layout
- ✅ Fixed viewport awareness for ALL AI creations (flowcharts, UI components, diagrams)
- ✅ Implemented group-aware collision detection to prevent placement inside complex diagrams
- ✅ Analyzed z-index implementation and decided against using it (documented rationale)
- ✅ Established pattern: calculate dimensions before placement
- ✅ All changes merged to main branch

**Commits in PR17**:
1. `cc67bd8` - feat: Implement intelligent branch detection for flowcharts
2. `cbfabba` - fix: Improve flowchart viewport awareness and prevent overlaps
3. `9b95cb2` - fix: Ensure all AI creations use accurate dimensions for viewport placement
4. `c9cef6c` - feat: Prevent AI from placing shapes over complex diagrams
5. `3c6b533` - Merge feature/ai-complex into main

**Critical Lessons**:

1. **Calculate Dimensions Before Placement** - Never estimate when you can calculate actual size. Create content in relative space (0,0), calculate bounding box, then place.

2. **Group-Aware Algorithms Essential** - Treat grouped shapes (flowcharts, UI components, diagrams) as single entities, not collections. Use bounding boxes and larger padding (50px vs 10px).

3. **Label-Based Routing Intuitive** - For flowchart branching, label detection ("Yes/No", "True/False") more intuitive than topology-only analysis.

4. **Not Every Feature Needs to Be Used** - Z-index exists but creation order is often sufficient. Consistency matters more than using every available feature.

5. **Document "Why Not" Decisions** - Record why certain approaches were rejected (like using z-index), not just what was implemented. Prevents future redundant discussions.

6. **Relative-Then-Absolute Positioning** - Calculate layout at (0,0) first, then apply offset to final position. Cleaner than absolute positioning throughout.

7. **Audit Comprehensively** - When fixing one issue (flowchart viewport), check if same issue exists elsewhere (UI components, diagrams). Fix systematically.

**Impact**: PR17 completed the complex AI commands system, enabling users to create sophisticated multi-shape structures (flowcharts with branching, UI components, diagrams) through natural language. Combined with PR15's shape creation and PR16's layout commands, Canvisia now supports full conversational canvas creation and organization.

**Next Steps**: Consider implementing undo support for complex commands, animated placement, and flowchart validation/auto-fix.
